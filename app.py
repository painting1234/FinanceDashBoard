import numpy as np
from scipy import stats
from scipy.stats import norm

from datetime import timedelta, date
import plotly.graph_objects as go

import dash
from dash import dcc
from dash import html
import dash_bootstrap_components as dbc
from dash.dependencies import Input, Output, State
from dash.exceptions import PreventUpdate

import pandas as pd
import yfinance as yf
import bt
import matplotlib.pyplot as plt


ticker_list = pd.read_csv('bats_symbols_bzx.csv')['Symbols']
default_ticker = 'SPY'
last_spot_price=100

app = dash.Dash(__name__, external_stylesheets=[dbc.themes.COSMO])
server = app.server

app.layout = html.Div([
    dbc.Tabs([
        dbc.Tab([
        dbc.Row([
            dbc.Col([
        dbc.Label('Select Asset'),
        dcc.Dropdown(id='stock_dropdown',
                 value=default_ticker,
                 options=[{'label': stock, 'value': stock}
                          for stock in ticker_list])
                ], md=3, lg=3)
        ]),
        dbc.Row([
            dbc.Col([
        dbc.Label('Select Strike Price'),
        dbc.Input(id='strike_price', type='number')
                ], md=3, lg=3)
        ]),
        dbc.Row([
        dbc.Col(id='current_price_output')
        ]),
        html.Br(),
        dbc.Col([
        dbc.Row([
            html.Br(),
            dbc.Label('Select historical period (days) for volatility calculation'),
            dbc.Label(id='Volatility Display', color='success'),
            dcc.Slider(id='vol_days_slider',
               min=0, max=3650, step=1, included=False,
               value=252,
               marks={days: str(days) for days in range(0, 365*11, 365)})
                ]),
    html.Br(),
    dbc.Row([
    dbc.Label('Select calendar days to expiration'),
    dbc.Label(id='expiration_display', color='success'),
    dcc.Slider(id='expiry_days_slider',
               min=1, max=365, step=1, included=False,
               value=90,
               marks={days: str(days) for days in range(0, 370, 10)})
    ]) # Row Close
        ], md=10, lg=10), # Column Close
    dbc.Col([
    dcc.Graph(id='black_scholes_chart'),
    html.Header(
        html.H4('How to Use this App'),
    ),
    html.P('''
    This app calculates the fair market price of a Call option, or the right to buy an equity at
    a given contract price. The fair market price is determined by the Black-Scholes pricing model: when the model
    price is below the quoted market price, the model says that the buyer has the advantage. Required inputs are:
    '''),
    html.Ol([
        html.Li('A stock or asset to analyze'),
        html.Br(),
        html.Li('The Strike Price: the Call Option buyer has the right to buy the equity at this price by the contract expiration date'),
        html.Br(),
        html.Li('''
        The length of time, in days, used to calculate the volatility. This is partly a judgment call; choose a shorter timeframe
        if you believe future volatility will reflect recent market trends or a longer timeframe
        if you believe volatility will revert to its long-term average
        '''),
        html.Br(),
        html.Li('''
        Calendar days to expiration: how many days until the contract runs out and the option can no longer be exercised.
        Longer times to expiration have more expensive options prices, since there is more time for the stock to make
        large movements
        ''')
    ])
    ])
        ], label='Option Price Calculator'), # Tab close
        
        dbc.Tab([
            dbc.Row([
                dbc.Col([
                    dbc.Label('Select Asset'),
                    dcc.Dropdown(id='stock_dropdown2',
                    value=default_ticker,
                    options=[{'label': stock, 'value': stock}
                          for stock in ticker_list])
                ],md=3, lg=3),
                dbc.Col([
                    dbc.Label('Number of Years to Simulate'),
                    dbc.Input(id='monte_carlo_years', type='number', value=10)
                ], md=3, lg=3)
            ]), # Row close
            dbc.Row([
                dcc.Graph(id='monte_carlo_chart')
            ]),
            html.Br(),
            html.P('''
            This chart shows the range of possible outcomes for $10,000 invested in a selected stock from the worst case (5th percentile) to
            best case (95th percentile) scenarios. The percentiles are based on 1,000 simulations of the stock using the full available
            history of its average growth and volatility. The simulated price movements are generated by drawing
            a random variable from a Normal distribution with a mean and standard deviation equal to the historical daily
            % price changes of the chosen asset.
            '''),
            html.P('''
            A limitation of this model is that it does not account for how a company may change over time,
            such as transitioning from a small-cap growth stock to a large-cap stock with lower growth expectations.
            ''')
        ], label='Monte Carlo Simulator') # Tab close
    ]) # Tabs close
], style={'padding': '0px 20px 20px 20px'})


# This is a chained callback that makes the current price of the selected stock the default value of the Strike Price
# See: https://dash.plotly.com/basic-callbacks
@app.callback(Output('strike_price', 'value'),
              Input('stock_dropdown', 'value'))
def default_strike_price(selected_stock):
              prices = yf.Ticker(selected_stock).history(period='1y', interval='1d')
              last_spot_price = np.round(prices['Close'][-1],0)
              return last_spot_price
            
# This is a chained callback that shows the Days to Expiration selected on the slider
# See: https://dash.plotly.com/basic-callbacks
@app.callback(Output('expiration_display', 'children'),
              Input('expiry_days_slider', 'value'))
def update_expiration_display(expiry_days_slider):
    EndDate = str(date.today() + timedelta(days=expiry_days_slider))
    return 'Option Expiring on: ' + EndDate

# Option Price Callback Function           
@app.callback(Output('black_scholes_chart', 'figure'),
              Output('current_price_output', 'children'),
              Output('Volatility Display', 'children'),
              Input('stock_dropdown', 'value'),
              Input('expiry_days_slider', 'value'),
              Input('strike_price', 'value'),
              Input('vol_days_slider', 'value'))
def black_scholes_chart(asset, expiry_days, strike_price, vol_days):
    ### Placeholder for State input ###
    #if not n_clicks:
    #    raise PreventUpdate
        
    prices = yf.Ticker(asset).history(period='100y', interval='1d')
    changes = prices.pct_change() # daily % returns
    last_spot_price = prices['Close'][-1]
    
    # Choose how wide of a range is plotted; 0.5 means 50% beyond strike price in either direction
    window = 0.5
    
    K = strike_price  # strike price from user input
    St = np.arange(np.round(K/(1+window),0), np.round(K*(1+window),0))      # Spot Price Range
    r = 0.01      # Risk Free Annual Interest Rate
    sigma = changes['Close'][-1*vol_days:-1].std()*np.sqrt(252)   # Annualized Volatility
    t = expiry_days/365    # Time to Maturity in Years
    
    # Call Price Function (Black Scholes Model)
    def black_scholes(K,St,r,sigma,t):
        d1 = (np.log(St/K) + (r + sigma**2/2)*t)/(sigma*t**0.5)
        d2 = d1 - sigma*(t**0.5)
        C = norm.cdf(d1)*St - norm.cdf(d2)*K*np.exp(-r*t)
        return C

    fig = go.Figure()
    
    # Coordinates for Option Price on graph; must be in list format for Plotly
    marker_x = [last_spot_price]
    marker_y = [black_scholes(K,last_spot_price,r,sigma,t)]
    
    # Plot option price curve (how option price changes with change in price of underlying)
    fig.add_scatter(x=St, y=black_scholes(K,St,r,sigma,t), name='Spot Price')
    
    # Plot vertical line to show current spot price
    fig.add_vline(last_spot_price, name='Current Price', annotation_text='Current Spot Price', line_width=1, line_dash='dash', line_color='gray')
    
    # Plot marker showing the fair value of the Call option at the selected strike price
    fig.add_scatter(x=marker_x, y=marker_y,
                    mode='markers',
                    marker=dict(line=dict(color='black', width = 2),
                    symbol = 'diamond',
                    size = 14,
                    color = 'rgba(255, 255, 0, 0.6)'),
                    name = 'Option Price')
    
    # Annotation to display option price
    fig.add_annotation(x=marker_x[0], y=marker_y[0],
                    text = 'Fair Option Price = ' + '${:,.2f}'.format(marker_y[0]),
                    font=dict(family="sans serif",
                                  size=18,
                                  color="black"),
                    ax=-K/(1+window)/2, #Sets x-component of annotation halfway between left margin and marker
                    ay=-100,
                    showarrow=True,
                    arrowhead=1)
    fig.layout.title = f'Call Option Price versus Spot Price: {asset} @ Strike Price = {strike_price}'
    fig.layout.xaxis.title = 'Spot Price'
    fig.layout.yaxis.title = 'Call Option Price'
    fig.update_xaxes(tickformat='$,')
    fig.update_yaxes(tickformat='$,')
    
    price_display = 'Current price of {}: ${:,.2f}'.format(asset, last_spot_price)
    vol_display = 'Volatility of {} over selected time period: {:,.2%}'.format(asset, sigma)
    return fig, price_display, vol_display


# Monte Carlo Chart
@app.callback(Output('monte_carlo_chart', 'figure'),             
              Input('stock_dropdown2', 'value'),
              Input('monte_carlo_years', 'value'))

def monte_carlo(asset, years):
    prices = yf.Ticker(asset).history(period='100y', interval='1d')['Close']
    changes = prices.pct_change()
    
    mu = np.mean(changes)
    std = np.std(changes)
    T = years*252
    N_steps = years
    step = int(np.round(T/N_steps,0))
    N_sims = 1000

    def forecast(mu, std, T):

        snapshots = []
        min_forecasts = []
        year_end_forecasts = []
        
        fig = go.Figure()
        S0 = 10000 # Starting Value
        
        for i in range(N_sims):
            rand_rets = np.random.normal(mu, std, T)+1
            forecasted_values = S0*(rand_rets).cumprod()
            
            # Get portfolio value snapshots throughout year and insert "S0" to plot starting portfolio value
            snapshot_prices = [forecasted_values[item] for item in np.arange(step-1, T, step)]
            snapshots.append([S0] + snapshot_prices)
            
            # Get minimum value, final value
            min_forecasts.append(forecasted_values.min())
            year_end_forecasts.append(forecasted_values[-1])
            
        return snapshots
            
    # Call forecast function
    snapshots = forecast(mu, std, T)
    
    # Calculate and plot each percentile line
    percentile_list = [5, 10, 20, 50, 80, 90, 95]
    
    fig = go.Figure()
    for percentile in percentile_list:
        fig.add_scatter(x=list(np.arange(0,years+1,1)), 
                        y=np.percentile(snapshots, percentile, axis=0), 
                        name=f'{percentile}th Percentile')
    fig.layout.title = f'{N_sims} Simulations of {asset} over {years} years'
    fig.layout.xaxis.title = 'Time (Years)'
    fig.layout.yaxis.title = 'Portfolio Value'
    fig.update_yaxes(tickformat='$,')
    return fig

if __name__ == '__main__':
    app.run_server(debug=True)
